"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const crypto_1 = require("crypto");
const fs = require("fs");
const _1 = require(".");
const deleteFolderRecursive = function (path) {
    if (fs.existsSync(path)) {
        fs.readdirSync(path).forEach(function (file, index) {
            var curPath = path + "/" + file;
            if (fs.lstatSync(curPath).isDirectory()) {
                // recurse
                deleteFolderRecursive(curPath);
            }
            else {
                // delete file
                fs.unlinkSync(curPath);
            }
        });
        fs.rmdirSync(path);
    }
};
deleteFolderRecursive("./logs");
_1.Logging.log("test");
_1.Logging.log("i", "am", { a: "an" }, 1000);
_1.Logging.error(new Error("fehler 001"));
_1.Logging.debug("Some Debug infos");
_1.Logging.errorMessage("i", "am", "an", "error");
_1.Logging.log("\x1b[31m\x1b[31m\x1b[31m\x1b[31m\x1b[31m\x1b[31m TEST \x1b[31m\x1b[31m\x1b[31m");
let err = new Error();
if (typeof err.stack !== "string")
    console.log("Stacktrace invalid", err.stack);
let cus = new _1.LoggingBase({ name: "test" });
cus.log("Hello from custom Logger");
let cus2 = new _1.LoggingBase("test2");
cus2.log("Hello from custom Logger 2");
let cus22 = new _1.LoggingBase("test2");
cus22.log("Hello from custom Logger 22");
cus2.log("Hello from custom Logger 2");
cus22.log("Hello from custom Logger 22");
cus2.log("Hello from custom Logger 2");
cus22.log("Hello from custom Logger 22");
cus2.log("Hello from custom Logger 2");
cus22.log("Hello from custom Logger 22");
cus2.log("Hello from custom Logger 2");
cus22.log("Hello from custom Logger 22");
cus2.log("Hello from custom Logger 2");
const BenchmarkLogger = new _1.LoggingBase({
    console: false,
    name: "bench",
});
async function benchmark(count, message_size) {
    await BenchmarkLogger.waitForSetup();
    const randData = crypto_1.randomBytes(message_size).toString("hex");
    const t = process.hrtime();
    for (let i = 0; i < count; i++) {
        BenchmarkLogger.log(randData);
    }
    const diff = process.hrtime(t);
    const NS_PER_SEC = 1e9;
    await BenchmarkLogger.waitForSetup();
    const ns = diff[0] * NS_PER_SEC + diff[1];
    console.log(`Benchmark took ${ns / 1000000}ms for ${count} messages with a size of ${message_size} characters`);
    console.log(`This is equal to ${ns / 1000000 / count} ms per message`);
}
_1.Logging.waitForSetup().then(async () => {
    return;
    console.log("Large data benchmark:");
    await benchmark(7000, 50000);
    console.log("Realdata data benchmark:");
    await benchmark(100000, 100);
});
const timer = _1.Logging.time("timer1", "Test Timer");
setTimeout(() => timer.end(), 1000);
//# sourceMappingURL=test.js.map