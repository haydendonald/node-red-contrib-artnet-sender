"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Files = exports.LoggingFiles = void 0;
const utils_1 = require("@hibas123/utils");
const fs = require("fs");
const path = require("path");
const logging_1 = require("@hibas123/logging");
const MAX_FILE_SIZE = 500000000;
class LoggingFiles {
    constructor(filename, error = false, maxFileSize = MAX_FILE_SIZE, noPrefix = false) {
        this.filename = filename;
        this.error = error;
        this.maxFileSize = maxFileSize;
        this.noPrefix = noPrefix;
    }
    init(observable) {
        observable.subscribe(this.onMessage.bind(this));
        if (!this.file) {
            this.file = Files.getFile(this.filename);
            return this.file.init(this.maxFileSize);
        }
    }
    flush(sync) {
        this.file.flush(sync);
    }
    onMessage(message) {
        // Just ignore all non error messages, if this.error is set
        if (this.error && message.type !== logging_1.LoggingTypes.Error)
            return;
        let prefix = "";
        if (message.name)
            prefix = `[${message.name}]=>`;
        let txt = message.text.formatted
            .map((fmt) => prefix + fmt.map((f) => f.text).join("") + "\n")
            .join("");
        let msg = Buffer.from(txt);
        this.file.write(msg);
    }
    close() {
        this.file.close();
        this.file = undefined;
    }
}
exports.LoggingFiles = LoggingFiles;
let Files = /** @class */ (() => {
    class Files {
        constructor(file) {
            this.file = file;
            this.open = 0;
            this.maxFileSize = MAX_FILE_SIZE;
            this.size = 0;
            this.stream = undefined;
            this.lock = new utils_1.Lock();
            this.$initialized = false;
            this.queue = [];
        }
        static getFile(filename) {
            filename = path.resolve(filename);
            let file = this.files.get(filename);
            if (!file) {
                file = new Files(filename);
                this.files.set(filename, file);
            }
            file.open++;
            return file;
        }
        get initlialized() {
            return this.$initialized;
        }
        async init(maxFileSize) {
            if (this.$initialized)
                return;
            let lock = await this.lock.getLock();
            this.maxFileSize == maxFileSize;
            await this.initializeFile();
            this.$initialized = true;
            lock.release();
            this.checkQueue();
        }
        async initializeFile(new_file = false) {
            try {
                if (this.stream) {
                    this.stream.close();
                }
                const folder = path.dirname(this.file);
                if (folder) {
                    if (!(await fsExists(folder))) {
                        await fsMkDir(folder).catch(() => { }); //Could happen, if two seperate instances want to create the same folder so ignoring
                    }
                }
                let size = 0;
                if (await fsExists(this.file)) {
                    let stats = await fsStat(this.file);
                    if (new_file || stats.size >= this.maxFileSize) {
                        if (await fsExists(this.file + ".old"))
                            await fsUnlink(this.file + ".old");
                        await fsMove(this.file, this.file + ".old");
                    }
                    else {
                        size = stats.size;
                    }
                }
                this.stream = fs.createWriteStream(this.file, { flags: "a" });
                this.size = size;
            }
            catch (e) {
                console.log(e);
                //ToDo is this the right behavior?
                process.exit(1);
            }
        }
        async checkQueue() {
            if (this.lock.locked)
                return;
            let lock = await this.lock.getLock();
            let msg;
            while ((msg = this.queue.shift())) {
                await this.write_to_file(msg);
            }
            lock.release();
        }
        async close() {
            await this.flush(false);
            this.open--;
            if (this.open <= 0) {
                this.stream.close();
                Files.files.delete(this.file);
            }
        }
        flush(sync) {
            if (sync) {
                // if sync flush, the process most likely is in failstate, so checkQueue stopped its work.
                let msg;
                while ((msg = this.queue.shift())) {
                    this.stream.write(msg);
                }
            }
            else {
                return Promise.resolve().then(async () => {
                    const lock = await this.lock.getLock();
                    lock.release();
                    await this.checkQueue();
                });
            }
        }
        async write_to_file(data) {
            try {
                if (data.byteLength < this.maxFileSize &&
                    this.size + data.byteLength > this.maxFileSize) {
                    await this.initializeFile(true);
                }
                this.size += data.byteLength;
                this.stream.write(data);
            }
            catch (err) {
                // TODO: Better error handling!
                console.error(err);
                this.initializeFile(false);
                this.write_to_file(data);
            }
        }
        write(data) {
            this.queue.push(data);
            this.checkQueue();
        }
        dispose() { }
    }
    Files.files = new Map();
    return Files;
})();
exports.Files = Files;
function fsUnlink(path) {
    return new Promise((resolve, reject) => {
        fs.unlink(path, (err) => {
            if (err)
                reject(err);
            else
                resolve();
        });
    });
}
function fsStat(path) {
    return new Promise((resolve, reject) => {
        fs.stat(path, (err, stats) => {
            if (err)
                reject(err);
            else
                resolve(stats);
        });
    });
}
function fsMove(oldPath, newPath) {
    return new Promise((resolve, reject) => {
        let callback = (err) => {
            if (err)
                reject(err);
            else
                resolve();
        };
        fs.rename(oldPath, newPath, function (err) {
            if (err) {
                if (err.code === "EXDEV") {
                    copy();
                }
                else {
                    callback(err);
                }
                return;
            }
            callback();
        });
        function copy() {
            fs.copyFile(oldPath, newPath, (err) => {
                if (err)
                    callback(err);
                else
                    fs.unlink(oldPath, callback);
            });
        }
    });
}
function fsExists(path) {
    return new Promise((resolve, reject) => {
        fs.exists(path, resolve);
    });
}
function fsMkDir(path) {
    return new Promise((resolve, reject) => {
        fs.mkdir(path, (err) => (err ? reject(err) : resolve()));
    });
}
//# sourceMappingURL=filewriter.js.map