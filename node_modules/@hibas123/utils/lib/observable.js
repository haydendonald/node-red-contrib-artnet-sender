"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _a;
"use strict";
const ClosedSymbol = Symbol("Observable Closed");
class Observable {
    constructor(collect_intervall = 100) {
        this.collect_intervall = collect_intervall;
        this.subscriber = [];
        this.subscriberCollect = [];
        this.events = [];
        this.timeout = undefined;
        // Use symbol to make sure this property cannot be changed from the outside
        this[_a] = false;
    }
    get closed() {
        return this[ClosedSymbol];
    }
    subscribe(callback) {
        if (this[ClosedSymbol])
            throw new Error("Observable is closed!");
        let oldcb = this.subscriber.find((e) => e === callback);
        if (!oldcb)
            this.subscriber.push(callback);
        return () => this.unsubscribe(callback);
    }
    unsubscribe(callback) {
        if (this[ClosedSymbol])
            return;
        let idx = this.subscriber.findIndex((e) => e === callback);
        if (idx >= 0) {
            this.subscriber.splice(idx, 1);
        }
        else {
            idx = this.subscriberCollect.findIndex((e) => e === callback);
            if (idx >= 0)
                this.subscriberCollect.splice(idx, 1);
        }
    }
    subscribeCollect(callback) {
        if (this[ClosedSymbol])
            throw new Error("Observable is closed!");
        let oldcb = this.subscriberCollect.find((e) => e === callback);
        if (!oldcb)
            this.subscriberCollect.push(callback);
    }
    /**
     * Creates Public API with subscribe and unsubscribe
     *
     * @returns {object}
     */
    getPublicApi() {
        if (this[ClosedSymbol])
            throw new Error("Observable is closed!");
        return {
            subscribe: (callback) => this.subscribe(callback),
            unsubscribe: (callback) => this.unsubscribe(callback),
            subscribeCollect: (callback) => this.subscribeCollect(callback),
        };
    }
    /**
     * Sends data to all subscribers
     * @param data data to be sent
     */
    send(data) {
        if (this[ClosedSymbol])
            throw new Error("Observable is closed!");
        Array.from(this.subscriber.values()).forEach((e) => {
            try {
                e(data);
            }
            catch (err) {
                // Catch error, so it doesn't affect other subscribers
                console.error(err);
            }
        });
        if (this.subscribeCollect.length > 0) {
            this.events.push(data);
            if (!this.timeout) {
                this.timeout = setTimeout(() => {
                    this.subscriberCollect.forEach((cb) => {
                        cb(this.events);
                    });
                    this.events = [];
                    this.timeout = undefined;
                }, this.collect_intervall);
            }
        }
    }
    /**
     * Closes Observable. This will remove all subscribers and mark this observable as closed.
     * You won't be able to reopen this observable. All maybe collected data will be discardet.
     */
    close() {
        this[ClosedSymbol] = true;
        this.subscriber = [];
        this.subscriberCollect = [];
        this.events = [];
        if (this.timeout)
            clearTimeout(this.timeout);
    }
}
_a = ClosedSymbol;
exports.default = Observable;
//# sourceMappingURL=observable.js.map