"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ConsoleAdapter = void 0;
const index_js_1 = require("./index.js");
const types_js_1 = require("./types.js");
const browser = typeof window !== "undefined" && typeof Deno === "undefined";
class ConsoleAdapter {
    constructor(colors = true) {
        this.colors = colors;
    }
    init(observable) {
        observable.subscribe(this.onMessage.bind(this));
    }
    flush() { }
    // TODO: Check if required!
    // private escape(text: string): string {
    //    return text
    //       .replace(/%s/g, "%%s")
    //       .replace(/%c/g, "%%c")
    // }
    formatLine(line) {
        let text = "";
        let style_formats = [];
        if (!browser) {
            for (let part of line) {
                let formats = "";
                for (let format of part.formats) {
                    switch (format.type) {
                        case types_js_1.FormatTypes.BOLD:
                            formats += types_js_1.TerminalFormats.Bold;
                            break;
                        case types_js_1.FormatTypes.UNDERSCORE:
                            formats += types_js_1.TerminalFormats.Underscore;
                            break;
                        case types_js_1.FormatTypes.BLINK:
                            formats += types_js_1.TerminalFormats.Blink;
                            break;
                        case types_js_1.FormatTypes.COLOR:
                            switch (format.color) {
                                case index_js_1.Colors.RED:
                                    formats += types_js_1.TerminalFormats.FgRed;
                                    break;
                                case index_js_1.Colors.GREEN:
                                    formats += types_js_1.TerminalFormats.FgGreen;
                                    break;
                                case index_js_1.Colors.YELLOW:
                                    formats += types_js_1.TerminalFormats.FgYellow;
                                    break;
                                case index_js_1.Colors.BLUE:
                                    formats += types_js_1.TerminalFormats.FgBlue;
                                    break;
                                case index_js_1.Colors.MAGENTA:
                                    formats += types_js_1.TerminalFormats.FgMagenta;
                                    break;
                                case index_js_1.Colors.CYAN:
                                    formats += types_js_1.TerminalFormats.FgCyan;
                                    break;
                                case index_js_1.Colors.WHITE:
                                    formats += types_js_1.TerminalFormats.FgWhite;
                                    break;
                            }
                            break;
                    }
                }
                text += formats + part.text + types_js_1.TerminalFormats.Reset;
            }
        }
        else {
            for (let part of line) {
                let styles = [];
                let resetStyles = [];
                for (let format of part.formats) {
                    switch (format.type) {
                        case types_js_1.FormatTypes.BOLD:
                            styles.push("font-weight: bold;");
                            resetStyles.push("font-weight: unset");
                            break;
                        case types_js_1.FormatTypes.UNDERSCORE:
                            styles.push("text-decoration: underline");
                            resetStyles.push("text-decoration: unset");
                            break;
                        case types_js_1.FormatTypes.BLINK:
                            styles.push("text-decoration: blink");
                            resetStyles.push("text-decoration: unset");
                            break;
                        case types_js_1.FormatTypes.COLOR:
                            let color = "";
                            switch (format.color) {
                                case index_js_1.Colors.RED:
                                    color = "red";
                                    break;
                                case index_js_1.Colors.GREEN:
                                    color = "green";
                                    break;
                                case index_js_1.Colors.YELLOW:
                                    color = "gold";
                                    break;
                                case index_js_1.Colors.BLUE:
                                    color = "blue";
                                    break;
                                case index_js_1.Colors.MAGENTA:
                                    color = "magenta";
                                    break;
                                case index_js_1.Colors.CYAN:
                                    color = "cyan";
                                    break;
                                case index_js_1.Colors.WHITE:
                                    color = "white";
                                    break;
                            }
                            styles.push("color: " + color);
                            resetStyles.push("color: unset");
                            break;
                    }
                }
                text += "%c" + part.text.replace(/%c/g, "%%c") + "%c";
                style_formats.push(styles.join(";"), resetStyles.join(";"));
            }
        }
        return [text, style_formats];
    }
    onMessage(message) {
        let lines = message.text.formatted;
        let prefix = "";
        if (message.name)
            prefix = `[${message.name}]=>`;
        if (browser) {
            if (this.colors) {
                let formats = [];
                let text = lines
                    .map((line) => {
                    let [t, fmts] = this.formatLine(line);
                    formats.push(...fmts);
                    return prefix + t;
                })
                    .join("\n");
                // console.log(formats);
                console.log(text, ...formats);
            }
            else {
                console.log(message.text.raw.join("\n"));
            }
        }
        else {
            if (this.colors) {
                lines.forEach((line) => {
                    let [text] = this.formatLine(line);
                    console.log(prefix + text);
                });
            }
            else {
                message.text.raw.forEach((line) => console.log(prefix + line));
            }
        }
    }
}
exports.ConsoleAdapter = ConsoleAdapter;
//# sourceMappingURL=consolewriter.js.map