"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.withColor = exports.LoggingBase = exports.removeColors = void 0;
const utils_1 = require("@hibas123/utils");
const consolewriter_js_1 = require("./consolewriter.js");
const inspect_js_1 = require("./inspect.js");
const types_js_1 = require("./types.js");
const browser = typeof window !== "undefined";
function removeColors(text) {
    text = text.replace(/[\u001b\u009b][[()#;?]*(?:[0-9]{1,4}(?:;[0-9]{0,4})*)?[0-9A-ORZcf-nqry=><]/g, "");
    // let index = text.indexOf("\x1b");
    // while (index >= 0) {
    //     text = text.substring(0, index) + text.substring(index + 5, text.length);
    //     index = text.indexOf("\x1b");
    // }
    return text;
}
exports.removeColors = removeColors;
const adapterCache = new WeakMap();
class AdapterSet {
    constructor() {
        this.change = new utils_1.Observable();
        this.adapters = new Set();
    }
    addAdapter(adapter) {
        if (!this.adapters.has(adapter)) {
            this.adapters.add(adapter);
            this.change.send({
                type: "add",
                adapter: adapter,
            });
        }
    }
}
const consoleAdapter = new consolewriter_js_1.ConsoleAdapter();
const PROJECT_ROOT = typeof process !== "undefined" ? process.cwd() : undefined;
class LoggingBase {
    constructor(options, adapterSet) {
        this._formatMap = new types_js_1.DefaultFormatConfig();
        this.adapter_init = [];
        this.timerMap = new Map();
        this.messageObservable = new utils_1.Observable();
        this._logLevel = types_js_1.LoggingTypes.Debug;
        this.#closed = false;
        let opt;
        if (!options)
            opt = {};
        else if (typeof options === "string") {
            opt = { name: options };
        }
        else {
            opt = options;
        }
        let config = {
            name: undefined,
            console: true,
            resolve_filename: true,
            ...opt,
        };
        if (config.name)
            this._name = config.name;
        this.resolve_filename = config.resolve_filename;
        for (let key in this) {
            if (typeof this[key] === "function")
                this[key] = this[key].bind(this);
        }
        if (adapterSet) {
            this.adapterSet = adapterSet;
            this.adapterSet.adapters.forEach((a) => this.initAdapter(a));
        }
        else {
            this.adapterSet = new AdapterSet();
        }
        this.adapterSet.change.subscribe((change) => {
            if (change.type === "add") {
                this.initAdapter(change.adapter);
            }
        });
        if (config.console) {
            this.addAdapter(consoleAdapter);
        }
        //Binding function to this
        this.debug = this.debug.bind(this);
        this.log = this.log.bind(this);
        this.warn = this.warn.bind(this);
        this.warning = this.warning.bind(this);
        this.error = this.error.bind(this);
        this.errorMessage = this.errorMessage.bind(this);
        this.flush = this.flush.bind(this);
    }
    set formatMap(value) {
        this._formatMap = value;
    }
    get logLevel() {
        return this._logLevel;
    }
    set logLevel(value) {
        this._logLevel = value;
    }
    get name() {
        return this._name;
    }
    /**
     * Can be used to override function from super class
     * @param child New child logging instance
     */
    postGetChild(child) { }
    /**
     * Creates a new logging instance, with the adapters liked together.
     * @param name Name/Prefix of the new child. The actual name will resolve as "<parent-name>/<name>"
     */
    getChild(name) {
        let lg = new LoggingBase({
            console: false,
            name: this.name ? this.name + "/" + name : name,
        }, this.adapterSet);
        return lg;
    }
    initAdapter(adapter) {
        let cached = adapterCache.get(adapter) || 0;
        adapterCache.set(adapter, cached + 1);
        let prms = Promise.resolve(adapter.init(this.messageObservable.getPublicApi()));
        this.adapter_init.push(prms);
    }
    addAdapter(adapter) {
        this.adapterSet.addAdapter(adapter);
    }
    flush(sync) {
        if (sync) {
            this.adapterSet.adapters.forEach((elm) => elm.flush(true));
        }
        else {
            let adapters = [];
            this.adapterSet.adapters.forEach((elm) => adapters.push(elm.flush(false)));
            return Promise.all(adapters).then(() => { });
        }
    }
    #closed;
    close() {
        if (this.#closed)
            return;
        this.#closed = true;
        this.adapterSet.adapters.forEach((adapter) => {
            let cached = adapterCache.get(adapter);
            if (cached) {
                cached--;
                if (cached <= 0) {
                    adapterCache.delete(adapter);
                    adapter.close();
                }
                else
                    adapterCache.set(adapter, cached);
            }
            adapter.close ? adapter.close() : undefined;
        });
        this.adapterSet = undefined;
        this.messageObservable.close();
    }
    waitForSetup() {
        return Promise.all(this.adapter_init);
    }
    debug(...message) {
        if (this._logLevel <= types_js_1.LoggingTypes.Debug)
            this.message(types_js_1.LoggingTypes.Debug, message);
    }
    log(...message) {
        if (this._logLevel <= types_js_1.LoggingTypes.Log)
            this.message(types_js_1.LoggingTypes.Log, message);
    }
    warning(...message) {
        if (this._logLevel <= types_js_1.LoggingTypes.Warning)
            this.message(types_js_1.LoggingTypes.Warning, message);
    }
    warn(...message) {
        if (this._logLevel <= types_js_1.LoggingTypes.Warning)
            this.message(types_js_1.LoggingTypes.Warning, message);
    }
    error(error, ...message) {
        if (this._logLevel > types_js_1.LoggingTypes.Error)
            return;
        if (!error)
            error = "Empty ERROR was passed, so no informations available";
        if (typeof error === "string") {
            let e = new Error("This is a fake error, to get a stack trace");
            this.message(types_js_1.LoggingTypes.Error, [
                error,
                "\n",
                e.stack,
                "\n",
                ...message,
            ]);
        }
        else {
            this.message(types_js_1.LoggingTypes.Error, [error.message, "\n", error.stack, "\n", ...message], getCallerFromExisting(error));
        }
    }
    errorMessage(...message) {
        if (this._logLevel <= types_js_1.LoggingTypes.Error)
            this.message(types_js_1.LoggingTypes.Error, message);
    }
    getCurrentTime() {
        if (browser && window.performance && window.performance.now) {
            return window.performance.now();
        }
        else {
            return Date.now();
        }
    }
    /**
     * The time difference in milliseconds (fractions allowed!)
     * @param start Start time from getCurrentTime
     */
    getTimeDiff(start) {
        if (browser && window.performance && window.performance.now) {
            return window.performance.now() - start;
        }
        else {
            return Date.now() - start;
        }
    }
    time(id, name = id) {
        if (!id) {
            id = Math.floor(Math.random() * 899999 + 100000).toString();
        }
        this.timerMap.set(id, {
            name,
            start: this.getCurrentTime(),
        });
        return {
            id,
            end: () => this.timeEnd(id),
        };
    }
    timeEnd(id) {
        let timer = this.timerMap.get(id);
        if (timer) {
            let diff = this.getTimeDiff(timer.start);
            this.message(types_js_1.LoggingTypes.Debug, [
                withColor(types_js_1.Colors.GREEN, `[${timer.name}]`),
                `->`,
                withColor(types_js_1.Colors.BLUE, diff.toFixed(4)),
                "ms",
            ]);
            return diff;
        }
        return -1;
    }
    message(type, message, caller) {
        if (this.#closed)
            return;
        let date = new Date().toISOString().replace(/T/, " ").replace(/\..+/, "");
        let file = undefined;
        if (this.resolve_filename) {
            let file_raw = caller;
            if (!file_raw) {
                try {
                    file_raw = getCallerFile();
                }
                catch (err) {
                    file_raw = {
                        file: "<unknown>",
                        line: 0,
                        column: 0,
                    };
                }
            }
            if (PROJECT_ROOT &&
                file_raw.file &&
                file_raw.file.startsWith(PROJECT_ROOT)) {
                let newF = file_raw.file.substring(PROJECT_ROOT.length);
                if (newF.startsWith("/") || newF.startsWith("\\"))
                    newF = newF.substring(1);
                file_raw.file = newF;
            }
            file = `${file_raw.file || "<unknown>"}:${file_raw.line}:${file_raw.column || 0}`;
        }
        let type_str = types_js_1.LoggingTypes[type].toUpperCase().padEnd(5, " ");
        let type_format = [];
        switch (type) {
            case types_js_1.LoggingTypes.Log:
                type_format = this._formatMap.log;
                break;
            case types_js_1.LoggingTypes.Error:
                type_format = this._formatMap.error;
                break;
            case types_js_1.LoggingTypes.Debug:
                type_format = this._formatMap.debug;
                break;
            case types_js_1.LoggingTypes.Warning:
                type_format = this._formatMap.warning;
                break;
        }
        const prefix = [];
        const a = (text, formats = []) => {
            prefix.push({
                text,
                formats,
            });
        };
        a("[");
        a(date, this._formatMap.date);
        a("][");
        a(type_str, type_format);
        if (file) {
            a("][");
            a(file, this._formatMap.file);
        }
        a("]: ");
        let raw = [];
        const formatted = [];
        let line;
        const newLine = () => {
            if (line && line.length > 0) {
                formatted.push(line);
                raw.push(line.map((e) => e.text).join(""));
            }
            line = [...prefix];
        };
        newLine();
        message.forEach((e, i) => {
            let formats = [];
            if (typeof e !== "string") {
                if (e && typeof e === "object") {
                    if (e[colorSymbol]) {
                        formats.push({
                            type: types_js_1.FormatTypes.COLOR,
                            color: e[colorSymbol],
                        });
                        e = e.value;
                    }
                }
                if (typeof e !== "string")
                    e = inspect_js_1.default(e, {
                        colors: true,
                        showHidden: true,
                        depth: 3,
                    });
            }
            removeColors(e)
                .split("\n")
                .map((text, index, { length }) => {
                line.push({ text, formats });
                if (index < length - 1) {
                    newLine();
                }
            });
            if (!e.endsWith("\n") && i < message.length - 1) {
                line.push({ text: " ", formats: [] });
            }
        });
        newLine();
        let msg = {
            date: new Date(),
            file,
            name: this._name,
            text: {
                raw,
                formatted,
            },
            type,
        };
        this.messageObservable.send(msg);
    }
}
exports.LoggingBase = LoggingBase;
const colorSymbol = Symbol("color");
function withColor(color, value) {
    return {
        [colorSymbol]: color,
        value,
    };
}
exports.withColor = withColor;
function getStack() {
    // Save original Error.prepareStackTrace
    let origPrepareStackTrace = Error.prepareStackTrace;
    try {
        // Override with function that just returns `stack`
        Error.prepareStackTrace = function (_, stack) {
            return stack;
        };
        // Create a new `Error`, which automatically gets `stack`
        let err = new Error();
        // Evaluate `err.stack`, which calls our new `Error.prepareStackTrace`
        let stack = err.stack;
        return stack;
    }
    finally {
        // Restore original `Error.prepareStackTrace`
        Error.prepareStackTrace = origPrepareStackTrace;
    }
}
function getCallerFile() {
    try {
        let stack = getStack();
        let current_file = stack.shift().getFileName();
        while (stack.length) {
            let caller_file = stack.shift();
            if (current_file !== caller_file.getFileName()) {
                return {
                    file: caller_file.getFileName(),
                    line: caller_file.getLineNumber(),
                    column: caller_file.getColumnNumber(),
                };
            }
        }
    }
    catch (err) { }
    return { file: undefined, line: 0 };
}
function getCallerFromExisting(err) {
    if (!err || !err.stack)
        return { file: "NOFILE", line: 0 };
    let lines = err.stack.split("\n");
    lines.shift(); // removing first line
    while (lines.length > 0) {
        let line = lines.shift();
        let matches = line.match(/[<]?([a-zA-Z]:)?([\/\\]?[a-zA-Z_-])+[.>][a-zA-Z_-]*([:][0-9]+)+/g);
        if (matches && matches.length > 0) {
            let match = matches[0].trim();
            let locationString = match.match(/([:][0-9]+)+$/gm)[0];
            let line;
            let column;
            if (locationString) {
                match = match.slice(0, match.length - locationString.length);
                locationString = locationString.substring(1);
                [line, column] = locationString.split(":").map(Number);
            }
            let file = match;
            return {
                file,
                line,
                column,
            };
        }
    }
}
//# sourceMappingURL=base.js.map