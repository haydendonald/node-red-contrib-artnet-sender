import { ObservableInterface } from "@hibas123/utils";

export enum LoggingTypes {
   Debug,
   Log,
   Warning,
   Error,
}

export const TerminalFormats = {
   Reset: "\x1b[0m",
   Bold: "\x1b[1m",
   Underscore: "\x1b[4m",
   Blink: "\x1b[5m",
   Reverse: "\x1b[7m",
   Hidden: "\x1b[8m",

   FgBlack: "\x1b[30m",
   FgRed: "\x1b[31m",
   FgGreen: "\x1b[32m",
   FgYellow: "\x1b[33m",
   FgBlue: "\x1b[34m",
   FgMagenta: "\x1b[35m",
   FgCyan: "\x1b[36m",
   FgWhite: "\x1b[37m",

   BgBlack: "\x1b[40m",
   BgRed: "\x1b[41m",
   BgGreen: "\x1b[42m",
   BgYellow: "\x1b[43m",
   BgBlue: "\x1b[44m",
   BgMagenta: "\x1b[45m",
   BgCyan: "\x1b[46m",
   BgWhite: "\x1b[47m",
};

export enum FormatTypes {
   COLOR,
   BOLD,
   UNDERSCORE,
   BLINK,
}

export enum Colors {
   NONE,
   RED,
   GREEN,
   YELLOW,
   BLUE,
   MAGENTA,
   CYAN,
   WHITE,
}

export interface FormatConfig {
   error: Format[];
   warning: Format[];
   log: Format[];
   debug: Format[];

   date: Format[];
   file: Format[];
}

function colorFormat(color: Colors) {
   return {
      type: FormatTypes.COLOR,
      color,
   };
}

const boldFormat = {
   type: FormatTypes.BOLD,
};

export class DefaultFormatConfig implements FormatConfig {
   error = [colorFormat(Colors.RED), boldFormat];
   warning = [colorFormat(Colors.YELLOW), boldFormat];
   log = [colorFormat(Colors.NONE), boldFormat];
   debug = [colorFormat(Colors.CYAN), boldFormat];

   date = [colorFormat(Colors.NONE)];
   file = [colorFormat(Colors.NONE)];
}

export interface Format {
   type: FormatTypes;
   color?: Colors;
}

export interface FormattedText {
   text: string;
   formats: Format[];
}

export type FormattedLine = FormattedText[];

export interface Message {
   type: LoggingTypes;
   name?: string;
   text: {
      raw: string[];
      formatted: FormattedLine[];
   };
   date: Date;
   file: string;
}

export interface Adapter {
   /**
    * This function initialises the Adapter. It might be called multiple times, when added to multiple instances
    * @param observable An observable to subscribe to messages
    */
   init(observable: ObservableInterface<Message>): void | Promise<void>;

   flush(sync: true): void;
   flush(sync: false): void | Promise<void>;

   /**
    * When a close function is available, it will be called when no logging instance references it anymore.
    *
    * WARNING: The adapter might be reinitialised, when it is added to a new Logging instance
    */
   close?(): void;
}
