import { ObservableInterface } from "@hibas123/utils";
import { Colors } from "./index.js";
import {
   Adapter,
   Message,
   FormattedLine,
   TerminalFormats,
   FormatTypes,
} from "./types.js";

declare const Deno: any;

const browser = typeof window !== "undefined" && typeof Deno === "undefined";

export class ConsoleAdapter implements Adapter {
   constructor(private colors: boolean = true) {}

   init(observable: ObservableInterface<Message>) {
      observable.subscribe(this.onMessage.bind(this));
   }

   flush() {}

   // TODO: Check if required!
   // private escape(text: string): string {
   //    return text
   //       .replace(/%s/g, "%%s")
   //       .replace(/%c/g, "%%c")
   // }

   private formatLine(line: FormattedLine): [string, string[] | undefined] {
      let text = "";
      let style_formats: string[] = [];

      if (!browser) {
         for (let part of line) {
            let formats = "";
            for (let format of part.formats) {
               switch (format.type) {
                  case FormatTypes.BOLD:
                     formats += TerminalFormats.Bold;
                     break;
                  case FormatTypes.UNDERSCORE:
                     formats += TerminalFormats.Underscore;
                     break;
                  case FormatTypes.BLINK:
                     formats += TerminalFormats.Blink;
                     break;
                  case FormatTypes.COLOR:
                     switch (format.color) {
                        case Colors.RED:
                           formats += TerminalFormats.FgRed;
                           break;
                        case Colors.GREEN:
                           formats += TerminalFormats.FgGreen;
                           break;
                        case Colors.YELLOW:
                           formats += TerminalFormats.FgYellow;
                           break;
                        case Colors.BLUE:
                           formats += TerminalFormats.FgBlue;
                           break;
                        case Colors.MAGENTA:
                           formats += TerminalFormats.FgMagenta;
                           break;
                        case Colors.CYAN:
                           formats += TerminalFormats.FgCyan;
                           break;
                        case Colors.WHITE:
                           formats += TerminalFormats.FgWhite;
                           break;
                     }
                     break;
               }
            }
            text += formats + part.text + TerminalFormats.Reset;
         }
      } else {
         for (let part of line) {
            let styles: string[] = [];
            let resetStyles: string[] = [];
            for (let format of part.formats) {
               switch (format.type) {
                  case FormatTypes.BOLD:
                     styles.push("font-weight: bold;");
                     resetStyles.push("font-weight: unset");
                     break;
                  case FormatTypes.UNDERSCORE:
                     styles.push("text-decoration: underline");
                     resetStyles.push("text-decoration: unset");
                     break;
                  case FormatTypes.BLINK:
                     styles.push("text-decoration: blink");
                     resetStyles.push("text-decoration: unset");
                     break;
                  case FormatTypes.COLOR:
                     let color = "";
                     switch (format.color) {
                        case Colors.RED:
                           color = "red";
                           break;
                        case Colors.GREEN:
                           color = "green";
                           break;
                        case Colors.YELLOW:
                           color = "gold";
                           break;
                        case Colors.BLUE:
                           color = "blue";
                           break;
                        case Colors.MAGENTA:
                           color = "magenta";
                           break;
                        case Colors.CYAN:
                           color = "cyan";
                           break;
                        case Colors.WHITE:
                           color = "white";
                           break;
                     }
                     styles.push("color: " + color);
                     resetStyles.push("color: unset");
                     break;
               }
            }
            text += "%c" + part.text.replace(/%c/g, "%%c") + "%c";
            style_formats.push(styles.join(";"), resetStyles.join(";"));
         }
      }

      return [text, style_formats];
   }

   onMessage(message: Message) {
      let lines = message.text.formatted;

      let prefix = "";
      if (message.name) prefix = `[${message.name}]=>`;

      if (browser) {
         if (this.colors) {
            let formats: string[] = [];
            let text = lines
               .map((line) => {
                  let [t, fmts] = this.formatLine(line);
                  formats.push(...fmts);
                  return prefix + t;
               })
               .join("\n");
            // console.log(formats);
            console.log(text, ...formats);
         } else {
            console.log(message.text.raw.join("\n"));
         }
      } else {
         if (this.colors) {
            lines.forEach((line) => {
               let [text] = this.formatLine(line);
               console.log(prefix + text);
            });
         } else {
            message.text.raw.forEach((line) => console.log(prefix + line));
         }
      }
   }
}
