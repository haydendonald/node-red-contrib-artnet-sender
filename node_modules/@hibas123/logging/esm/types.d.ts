import { ObservableInterface } from "@hibas123/utils";
export declare enum LoggingTypes {
    Debug = 0,
    Log = 1,
    Warning = 2,
    Error = 3
}
export declare const TerminalFormats: {
    Reset: string;
    Bold: string;
    Underscore: string;
    Blink: string;
    Reverse: string;
    Hidden: string;
    FgBlack: string;
    FgRed: string;
    FgGreen: string;
    FgYellow: string;
    FgBlue: string;
    FgMagenta: string;
    FgCyan: string;
    FgWhite: string;
    BgBlack: string;
    BgRed: string;
    BgGreen: string;
    BgYellow: string;
    BgBlue: string;
    BgMagenta: string;
    BgCyan: string;
    BgWhite: string;
};
export declare enum FormatTypes {
    COLOR = 0,
    BOLD = 1,
    UNDERSCORE = 2,
    BLINK = 3
}
export declare enum Colors {
    NONE = 0,
    RED = 1,
    GREEN = 2,
    YELLOW = 3,
    BLUE = 4,
    MAGENTA = 5,
    CYAN = 6,
    WHITE = 7
}
export interface FormatConfig {
    error: Format[];
    warning: Format[];
    log: Format[];
    debug: Format[];
    date: Format[];
    file: Format[];
}
export declare class DefaultFormatConfig implements FormatConfig {
    error: {
        type: FormatTypes;
    }[];
    warning: {
        type: FormatTypes;
    }[];
    log: {
        type: FormatTypes;
    }[];
    debug: {
        type: FormatTypes;
    }[];
    date: {
        type: FormatTypes;
        color: Colors;
    }[];
    file: {
        type: FormatTypes;
        color: Colors;
    }[];
}
export interface Format {
    type: FormatTypes;
    color?: Colors;
}
export interface FormattedText {
    text: string;
    formats: Format[];
}
export declare type FormattedLine = FormattedText[];
export interface Message {
    type: LoggingTypes;
    name?: string;
    text: {
        raw: string[];
        formatted: FormattedLine[];
    };
    date: Date;
    file: string;
}
export interface Adapter {
    /**
     * This function initialises the Adapter. It might be called multiple times, when added to multiple instances
     * @param observable An observable to subscribe to messages
     */
    init(observable: ObservableInterface<Message>): void | Promise<void>;
    flush(sync: true): void;
    flush(sync: false): void | Promise<void>;
    /**
     * When a close function is available, it will be called when no logging instance references it anymore.
     *
     * WARNING: The adapter might be reinitialised, when it is added to a new Logging instance
     */
    close?(): void;
}
